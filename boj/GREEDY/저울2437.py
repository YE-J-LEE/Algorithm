import sys

# 예전에 동기가 어려운 문제라고 소개해준 적이 있어서 함정 존재 유무를 알고 있긴 했다.
# 하지만 이번엔 함정에 대해서 조사해봤다.
# 언뜻보면 저울의 개수 N 은 1000개 까지고 각 추의 무게는 100만까지 가능하다.
# 그렇다면 최악의 경우 잴 수 있는 무게의 max 범위는 10억이다.
# 그렇다면 저 범위는 되는지 안되는지 여부를 따질만한 1차원 배열로도 구현할 수 없으며 따라서
# 이분 탐색으로 풀 수 있는 지에 대해 찾게 된다.
# 하지만 이분 탐색으로 풀기엔 mid 값을 정한 뒤 왼쪽으로 좁힐지 오른쪽으로 좁힐지 알 수가 없다.
# 왜냐면 무게가 제각각이기에 안 되는 무게가 듬성듬성 존재하기 때문이다.
# 따라서 무게는 그저 수치, 수계산을 위할 뿐이고 주어진 1000까지의 N만 시간복잡도에 영향이 가게끔 사용해야 한다.
# 그렇다면 우리는 O(N) 혹은 O(N^2)의 시간복잡도 풀이를 생각해볼 수 있다.
# 만약 DP로 풀이 한다면 어떤 수들을 통해 하나의 수를 이뤄야 하므로 2차원 배열이 적용될 것이며 이는 10억이 되므로 배제한다.
# 문제에선 최솟값을 묻고 있다. 그렇다면 남은건 그리디라는 말이다.
# 앞에서부터 숫자를 만들 수 있는지 여부를 파악해보자. 이를 위해 우선 정렬을 한다.
# 매 시점마다 만들고자 하는 수, 그러니까 정답이 될 수 있는 수는 여태까지 만들 수 있는 수보다 1만 크면 된다.
# 그리고 바로 이 1만 크면 된다는 조건으로 인해 그 이전에 만들어진 수들이 0차이나 1차이 정도면 만들 수 있게 된다.
# 왜냐하면 큰 지장 없이 진행됐을 경우 이전의 만들 수 있는 숫자들은 1~ 현재까지 등차가 1인 상태로 존재하기에,
# 새롭게 노릴 target을 웬만하면 만들 수 있기 때문이다.
# 이 생각이 이 문제의 난이도를 결정하는 사안이다. 생각하기 꽤 까다롭고 숫자들의 규칙에 대해 어느 정도 체화가 되어야 하는 그런 문제 같다.

N = int(sys.stdin.readline())
weight = sorted(list(map(int, sys.stdin.readline().split())))
enable = 0
for w in weight:
    target = enable + 1
    if w <= target:
        enable += w
    else:
        break
print(enable + 1)
