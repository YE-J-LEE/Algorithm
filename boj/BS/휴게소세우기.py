import sys

# 이분 탐색 문제였다. 근데 이제 매개 변수 탐색을 곁들인..
# 일직선상으로 무언가 설치되어 있고 그 선을 왼쪽부터 지나가며, 최종적으로 최댓값의 최솟값을 묻는다.
# 이런 레퍼토리의 문제는 프로그래머스의 징검다리 (level 4) 문제와 비슷한 양상이다.
# 물론 오래되었지만 징검다리 문제를 본 적이 있어서 이분탐색의 냄새가 살짝 나긴 했다.
# 하지만 최근에 푼 문제들이 대부분 DP였고, 또 그리디하게 계속해서 구간이 제일 큰 부분을 반으로 갈라버리면
# 최종적으로 남는 가장 긴 구간이 만들어질 수 있는 긴 구간 중 가장 최소가 아닐까 싶어 우선순위 큐에 넣고
# 계속해서 반갈을 진행했지만 주어진 테케에서 오답!
# 그래서 DP 점화식을 구상해보았지만 문제에서 요구하는 것이 최댓값의 최솟값, 그리고 DP라면 이전에 구한 값을
# 다시 재사용해야 하는데 아무리 생각해봐도 어떤식으로 재사용해야할지 구상이 안 됐다.
# 그래서 알고리즘 분류를 살펴보니 아니나 다를까 매개 변수를 곁들인 이분 탐색이다!
# 그래서 보자마자 바로 프로그래머스에서 예전 PS공부 초창기에 만났던 장벽인 징검다리 문제가 떠올랐다.
# 이렇게 보니 그 문제와 너무 비슷한 양상이었다.
# 그래서 나만의 이분 탐색 접근법으로 접근해보았다. 먼저 정답이 ~다 라고 생각하고 찔러보는 방식이다.
# 주어진 테케의 정답인 70의 위 아래로 만약 정답이 100일 경우와 정답이 50인 경우
# 최소 몇 갠는 만들어놔야 최대 구간이 100 혹은 50을 유지하는지 체크해봤고
# 이를 통해 bound를 지정할 수 있었고 빠르게 코드를 설계한 뒤에 나타날 수 있는 엣지 케이스들 테스트까지 진행해주고
# 바로 통과할 수 있었다.
'''
정답보다 큰 경우(100이라 할때) 최소 5개는 만들어놓고 갈라야 max 구간 100을 유지 가능
0 ~ 82        0
82 ~ 201     1
201 ~ 411    2
411 ~ 555   1
555 ~ 622    0
622 ~ 755    1
755 ~ 800    0

정답보다 작은 경우 (50이라 할때) 최소 12개는 만들어놓고 갈라야 max 구간 50을 유지 가능

0 ~ 82        1
82 ~ 201     2
201 ~ 411    4
411 ~ 555   2
555 ~ 622    1
622 ~ 755    2
755 ~ 800    0
'''

def atLeastOver(interval):
    start = 0
    result = 0
    for end in shelter:
        if end == 0:
            continue
        result += (end-start-1)//interval
        start = end
    return result

N, M, L = map(int, sys.stdin.readline().split())
shelter = sorted(list(map(int, sys.stdin.readline().split())))
shelter.append(L)
answer = -1
start = 0
end = L
while start <= end:
    mid = (start+end)//2
    atLeast = atLeastOver(mid)
    if atLeast <= M:
        answer = mid
        end = mid - 1
    else:
        start = mid + 1
print(answer)

