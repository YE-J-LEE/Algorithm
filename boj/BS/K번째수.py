import sys

# 정말 다양하게 풀이를 생각해봤던 문제다.
# 처음엔 행렬을 그려보고 규칙을 찾아봤다. 대각선을 기준으로 대칭성을 띄었고 이 규칙을 활용해 푸는 문제일까 시도해봤다.
# 하지만 하나의 기준을 잡기엔, 해당 기준으로부터 벗어난 행렬에서 영향을 주고 또 이때문에 이전 값을 재사용한다는 개념도 적용할 수 없었다.
# 따라서 이전의 행위가 반복되는 것이 뚜렷하게 존재하지 않기에 그리디나 DP로는 풀 수 없었다.
# 그리고 지금 적으며 생각해보니 ~의 최솟값이나 최댓값을 묻는 문제도 아니다.
# 그리고 마지막까지 생각해본 순수 나의 접근법은 1부터 k까지 각각의 숫자들이 몇번 등장하는지였다.
# 이렇게 되면 누적합을 통해 문제에서 묻는 k번째수를 구할 수 있었다.
# 그래서 로직을 코드로 써내려가보니 이는 시간초과가 자명했다.
# 또한 N과 k의 범위를 살펴보니 적당히 N*logN이나 k*logk이던 하나의 범위에서 그에 대한 log시간이 곱해진, 그러니깐
# 마침 행렬들을 풀어써서 오름차순 한다고 했으니 이분탐색을 접목시키면 나올 것 같았다.
# 하지만 이분탐색에 대한 나의 접근법인 답은 뭐다로 정해놓고 이를 체크하기엔.. 예측답에 대한 등수 구하는 로직이 구상이 안 됐다.
# 왜냐면 내가 생각한 어떠한 값에 대한 등수는 이전까지의 약수들의 합이기에, 위에서 이미 시도했을때 시간초과가 자명했기 때문이다.
# 결국 다른 사람의 풀이를 보았고 어떠한 하나의 값에 대해서 해당 등수를 O(N) 시간 내에 구할 수 있다는 사실을 알게 되었다.
# 어떠한 수의 배수로 이어진 수들 중에서 특정값 이하 수들의 개수를 구하기 위해 //를 사용한다는 것을 이번에 확실히 각인시켰다.

N = int(sys.stdin.readline())
k = int(sys.stdin.readline())
start = 1
end = k
answer = -1
while start <= end:
    mid = (start+end)//2
    rating = 0
    for i in range(1, N+1):
        rating += min(mid//i, N)
    if rating >= k:
        answer = mid
        end = mid - 1
    else:
        start = mid + 1
print(answer)