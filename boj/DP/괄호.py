# 문제에서의 힌트인 S + T or (S)만을 사용하기엔 함정이 있었다. (단, S와 T는 올바른 괄호)
# 이는 L = 6 일때 나타나는데, ()(())와 같은 경우는 내가 짠 (S) 안의 S 즉, 올바른 괄호가 아니어도 되는 경우가 발생해 미스가 난다.
# 그래서 저 두 가지 방식만을 사용하는 방법을 넘어서서 순수하게 올바른 문자열만을 재사용하는게 아닌 모든 경우를 볼 수 있어야 한다.
# 좀 더 본질적으로 파고들어보자.
# 시작은 무조건 (이다. 그리고 이 친구를 닫아줄 수 있는 괄호 )가 그 이후 어딘가에 반드시 존재한다.
# 따라서 (와  ) 사이, 그리고 )의 이후 총 두 군데를 해당 길이일 때의 올바른 괄호값 개수로 두고 재사용하면 된다.
# 물론 하나의 시점만 봤을 때 두 군데 모두 올바른 괄호값이 아니어도 전체적으로 볼 때 올바른 괄호인 경우가 있을 수 있다.
# 바로 이 점이 내가 적용하지 못 한 부분인데, 사실 문제에서 L의 크기 5000을 가지고 힌트를 줬다.
# 왜냐하면 충분히 O(N^2)으로 돌아갈 크기이고, for 문을 두 번 쓰라는 의미로 받아들일 수 있단 사실이다.
# 그래서 앞의 (는 고정이지만 뒤의 )는 for문을 한 번 더 사용함으로써 12line에서 내가 언급한 부분이 충분히 커버된다.

import sys

DP = [0]*5001
DP[2] = 1

for i in range(4, 5001, 2):
    start = 0
    if i%2 != 0:
        continue
    for j in range(1, i):
        left = j - start - 1
        right = i - j - 1
        if left == 0:
            DP[i] += DP[right]
        elif right == 0:
            DP[i] += DP[left]
        else:
            DP[i] += DP[left]*DP[right]

T = int(sys.stdin.readline())
for _ in range(T):
    L = int(sys.stdin.readline())
    print(DP[L]%1000000007)




