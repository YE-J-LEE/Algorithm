import sys

# BOJ 1790
# 이 문제는 특정 구간에 존재할 수 있는 수들의 갯수를 활용하여 특정 번째에는 어떠한 수가 있는지 맞추는,,
# 내가 정말 싫어하는 문제 중 하나이다. 처음에 보고 도망갈까 싶었지만 편식할 수가 없어서 먹어보게 되었다.
# 맞추고 싶은 k번째수에서 k 값의 범위가 10의 9제곱이다. 이거 아무리 파이썬이 넉넉한 (long long따위 취급 안함) 언어라고 해도
# 스트링에 담아도 k번째까지 for문으로 이동하는 도중에 터진다 분명.
# 이 말은 철저히 규칙에 따라 계산해서 맞추란 의미다.
# 그래서 구간별로 몇개가 존재하는지에 따라서 몇번째 수인지 찾아야 했다.
# 내가 이러한 문제를 싫어하는 이유는, 우선 각 구간에 몇개까지 존재하는지 파악하는 데에 머리가 아프다. 밑에서도 주석으로 통해
# 각 구간별 숫자 갯수를 세고 있는 것을 볼 수 있다. 그리고 이 다음이 또 문제다.
# 몇번째인지 범위 구간을 찾았다고 해도, 거기서 또 세분화 해서 몇 번째인지 2차적으로 찾아야 한다.
# 바로 이 부분에서 나눗셈(//)몫이나 나머지(%)를 통해 다시 또 유추해야하는데 이게 또 나누어 떨어지고 아니고에 따라서
# 나눌 숫자에 +1혹은 -1을 어느 시점에 해야하는지 테스트해봐야한다.. 조금이라도 엇나가면 잘못된 값을 반환하기에..
# 테스트케이스를 통해 테스트하며 풀어내긴 했지만.. 이 부분은 성장 경험치가 그렇게 많이 차는 것 같지 않다..

N, k = map(int, sys.stdin.readline().split())
# 1: 1 ~ 9 = 9 * 1
# 2: 10 ~ 99 = 90 * 2
# 3: 100 ~ 999 = 900 * 3
# 4: 1000 ~ 9999 = 9000 * 4
# ~ 8자릿수, 9자릿수는 하나
n = len(str(N))

rate = [0]*(n+1)
num = 9
for i in range(1, n):
    rate[i] = num*i
    num *= 10
rate[n] = (N - 10**(n-1) + 1)*n
for i in range(1, n+1):
    rate[i] += rate[i-1]
for i in range(n+1):
    if k <= rate[i]:
        k -= rate[i-1]+1
        start = 10**(i-1)
        start += k//i
        print(str(start)[k%i])
        break
else:
    print(-1)

