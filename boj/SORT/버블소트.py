import sys

# BOJ 1377
# 정렬에 대한 관찰력이 중요했던 문제이다.
# 처음에 접근한 방식으로는 버블소트에서 반복문마다 제일 큰 친구를 맨 오른쪽으로 보내버리는 방식인 점에 착안해
# LIS 길이를 구하고 이를 전체 길이에서 빼면 큰 친구들이 넘어가는 횟수 즉, 버블소트가 수행된 횟수가 나올 것이라고 생각했다.
# 하지만 LIS가 '가장' 긴 길이인 것 때문에 반례가 생겨 틀려버렸고, 결국엔 버블소트가 수행된 횟수를 구하는 새로운 방법을 찾아야 했다.
# 결국엔 풀지 못 해 다른 사람들의 풀이를 참고하였고, 버블 소트 함수 내의 swap부분에 중심을 두었어야 했다는 걸 알게 되었다.
# 버블 소트의 종료란, swap 행위가 더 이상 일어나지 않았다는 것을 의미한다.
# 따라서 swap을 통해 왼쪽으로 이동하는 애들 중 가장 큰 값에 1을 더한게 버블소트의 가장 바깥 반복문 수행 횟수와 같다는 것을 알게 되었다.
# 다음부터 정렬과 관련된 문제는 break 지점을 제대로 관찰해야 하고 인덱스 역시 활용해야 겠다는 생각을 하게 되었다.

N = int(sys.stdin.readline())
A = []
for i in range(N):
    num = int(sys.stdin.readline())
    A.append((num, i))
A.sort()
answer = 0
for i in range(N):
    answer = max(answer, A[i][1] - i + 1)
print(answer)